Title: Customizing the Viewer

The Wicket viewer allows you to customize the GUI in several ways:

* through CSS
* through Javascript snippets (eg JQuery)
* by replacing elements of the page
* by providing additional views of collections
* by providing new pages

Each of these is described in more detail below.

### Customizing the CSS ###

The most straight-forward way to customize the Wicket viewer's UI is to use CSS.    For example, you could use CSS to suppress the entity's icon alongside its title.  This would be done using:

    .entityIconAndTitlePanel a img {
    	display: none;
    }


These customizations should be added to `src/main/webapp/css/application.css`; this file is included by default in every webpage served up by the Wicket viewer.

If for some reason you wanted to name the CSS file differently (eg `stylesheets/myapp.css`), then adjust the Guice bindings (part of Isis' bootstrapping) in your custom subclass of `IsisWicketApplication`:

    public class MyAppApplication extends IsisWicketApplication {
        @Override
        protected Module newIsisWicketModule() {
            final Module isisDefaults = super.newIsisWicketModule();
            final Module myAppOverrides = new AbstractModule() {
                @Override
                protected void configure() {
                    ...
                    bind(String.class)
                        .annotatedWith(Names.named("applicationCss"))
                        .toInstance("stylesheets/myapp.css");
                    ...
                }
            };
    
            return Modules.override(isisDefaults).with(myAppOverrides);
        }
    }

As indicated above, this file is resolved relative to `src/main/webapp`.

### Customizing using Javascript snippets ###

It is also possible to provide custom Javascript (eg to run some arbitrary JQuery on page load), and to change the application name, welcome and about messages.  This is done through the Guice bindings:

    bind(String.class)
        .annotatedWith(Names.named("applicationJs"))
        .toInstance("scripts/application.js");

You might have noticed that the application name, welcome message and about message can also be customized:

    bind(String.class)
        .annotatedWith(Names.named("applicationName"))
         .toInstance("My Wonderful App");
    bind(String.class)
        .annotatedWith(Names.named("welcomeMessage"))
        .toInstance(readLines("welcome.html"));
    bind(String.class)
        .annotatedWith(Names.named("aboutMessage"))
        .toInstance("My Wonderful App v1.0");

Again, the `welcome.html` file is resolved relative to `src/main/webapp`.

### Replacing Components (elements of the page) 

The pages generated by Isis' Wicket viewer are built up of numerous elements,
from fine-grained widgets for property/parameter fields, to much larger components that take responsibility for rendering an entire entity entity, or a collection of entities.  Under the covers these are all implementations of the the Apache Wicket `Component` API.  The larger components delegate to the smaller, of course.

##### How the Wicket viewer selects components
Components are created using Isis' `ComponentFactory` interface, which are registered in turn through the `ComponentFactoryRegistrar` interface.  Every
component is categorizes by type (the `ComponentType` enum), and Isis uses this to determine which `ComponentFactory` to use.  For example, the `ComponentType.BOOKMARKED_PAGES` is used to locate the `ComponentFactory` that will build the bookmarked pages panel.

Each factory is also handed a model (an implementation of `org.apache.wicket.IModel`) appropriate to its `ComponentType`; this holds the data to be rendered.  For example, `ComponentType.BOOKMARKED_PAGES` is given a `BookmarkedPagesModel`, while `ComponentType.SCALAR_NAME_AND_VALUE` factories are provided a model of type of type `ScalarModel` .   

In some cases there are several factories for a given `ComponentType`; this is most notably the case for `ComponentType.SCALAR_NAME_AND_VALUE`.  After doing a first pass selection of candidate factories by `ComponentType`, each factory is then asked if it `appliesTo(Model)`.  This is an opportunity for the factory to check the model itself to see if the data within it is of the appropriate type.

Thus, the `BooleanPanelFactory` checks that the `ScalarModel` holds a boolean, while the `JodaLocalDatePanelFactory` checks to see if it holds  `org.joda.time.LocalDate`.  

There will typically be only one `ComponentFactory` capable of rendering a particular `ComponentType`/`ScalarModel` combination; at any rate, the framework stops as soon as one is found.  (*There is one exception to this design, discussed below in the next section "Additional Views of Collections"*).

##### How to replace a component 
This design (the [chain of responsibility](http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern) design pattern) makes it quite straightforward to change the rendering of any element of the page.  For example, you might switch out Isis' sliding bookmark panel and replace it with one that presents the bookmarks in some different fashion.

First, you need to write a `ComponentFactory` and corresponding `Component`.  The recommended approach is to start with the source of the `Component` you want to switch out.  For example:

    public class MyBookmarkedPagesPanelFactory 
        extends ComponentFactoryAbstract {

        public MyBookmarkedPagesPanelFactory() {
            super(ComponentType.BOOKMARKED_PAGES);
        }
    
        @Override
        public ApplicationAdvice appliesTo(final IModel<?> model) {
            return appliesIf(model instanceof BookmarkedPagesModel);
        }
    
        @Override
        public Component createComponent(final String id, final IModel<?> model) {
            final BookmarkedPagesModel bookmarkedPagesModel = (BookmarkedPagesModel) model;
            return new MyBookmarkedPagesPanel(id, bookmarkedPagesModel);
        }
    }

and

    public class MyBookmarkedPagesPanel 
        extends PanelAbstract<BookmarkedPagesModel> {
       ...
    }

Here `PanelAbstract` ultimately inherits from `org.apache.wicket.Component`.
Your new `Component` uses the information in the provided model (eg `BookmarkedPagesModel`) to know what to render.

Next, you will require a custom implementation of the `ComponentFactoryRegistrar` that registers your custom `ComponentFactory` as a replacement:

    @Singleton
    public class MyComponentFactoryRegistrar extends ComponentFactoryRegistrarDefault {
    
        @Override
        public void addComponentFactories(ComponentFactoryList componentFactories) {
            super.addComponentFactories(componentFactories);
            componentFactories.replace(new MyBookmarkedPagesPanelFactory());
        }
    }

This will take the place of Isis' default implementation.

Finally (as for other customizations), you need to adjust the Guice bindings in your custom subclass of `IsisWicketApplication`:

    bind(ComponentFactoryRegistrar.class)
        .to(MyComponentFactoryRegistrar.class);

##### Replacing an Object View (eg a Dashboard)

One replacement in particular is worth highlighting; the rendering of an entire entity.  Normally this is done using `EntityCombinedPanelFactory`, this being the first `ComponentFactory` for the `ComponentType.ENTITY` that is registered in Isis default `ComponentFactoryRegistrarDefault`.

You could, though, register your own `ComponentFactory` for entities that is targeted at a particular class of entity - some sort of object representing a dashboard, for example.  It can use the `EntityModel` (provided to it) to determine the class of the entity to inspect whether it is of the appropriate type.  It should also be registered before the `EntityCombinedPanelFactory` so that it gets a chance to render in its stead.

### Additional Views of Collections

As explained above, in most cases Isis' Wicket viewer will search for the first `ComponentFactory` that can render an element, and use it.  In the case of (either standalone or parented) collections, though, Isis will show all available views.

For example, out-of-the-box Isis provides an table view, a summary view (totals/sums/averages of any data), and a collapsed view (for `@Render(LAZILY)` collections).  These are selected by clicking on the toolbar by each collection.

Additional views though could render the objects in the collection as a variety of ways.  Indeed, some third-party implementations already exist:

  * [excel integration](https://github.com/danhaywood/isis-wicket-excel) (collection as a downloadable excel spreadsheet)
  * [google maps v3 integration](https://github.com/danhaywood/isis-wicket-gmap3) (render any objects with a location on a map)
  * [wicked charts integration](https://github.com/danhaywood/isis-wicket-wickedcharts) (barchart of any data)
  * [full calendar integration](https://github.com/danhaywood/isis-wicket-fullcalendar) (render any objects with date properties on a calendar)
  
Registering these custom views is just a matter of adding the appropriate Maven module to the classpath.  Isis uses the JDK `ServiceLoader` API to automatically discover and register the `ComponentFactory` of each such component.

If you want to write your own alternative component and auto-register, then include a file `META-INF/services/org.apache.isis.viewer.wicket.ui.ComponentFactory` whose contents is the fully-qualified class name of the custom `ComponentFactory` that you have written.

Wicket itself has lots of components available at its [wicketstuff.org](http://wicketstuff.org) companion website; you might find some of these useful for your own customizations.

### Custom Pages ###

In addition to replacing elements of a page, it is also possible to define completely new pages.  

Isis defines precisely five page types

* SIGN_IN 
* HOME 
* ABOUT 
* ENTITY 
* ACTION

The last of these is multi-functioned; it is used to render an action parameter, and also to render a standalone collection.

The `PageClassList` declares which class (subclass of `org.apache.wicket.Page` is used to render for each of these types.  For example, Isis' `WicketSignInPage` renders the signin page.  To specify a different page class, create a custom subclass of `PageClassList`:

    @Singleton
    public class MyPageClassList extends PageClassListDefault {

        protected Class<? extends Page> getSignInPageClass() {
            return MySignInPage.class;
        }
    }

and register through the Guice bindings:

    bind(PageClassList.class).to(MyPageClassList.class);


