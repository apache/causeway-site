Fixture Scripts
===============

Fixture scripts are intended to support development and testing, by setting up the system into a known state.  A fixture
script are invoked using a "fixture script" service, and typically either call business actions on domain objects, or
call other fixture scripts (that is, the composite pattern).

One simple, but noteworthy point about fixture scripts is that they can be invoked through the UI.  This makes them
useful for more than "just" testing:

* If working with your domain experts/business analyst, fixture scripts allow you to set up the app in the appropriate
  state to start exploring proposed new functionality
  
* if implementing a user story/feature, fixture scripts (by setting up the system into a specific state) can make it 
  faster for you to manually verify that you've implemented the functionality correctly
  
* if writing automated [integration tests](../core/integtestsupport.html), the fixture scripts can be used as the
  "given" in a "given/when/then" style test
  
* if demo'ing your feature to the domain experts/stakeholder, fixture scripts can automate any tedious setup prior to
  demoing that feature.
  
* if performing manual/exploratory testing or user acceptance testing, the fixture script can setup the system into
  a known state for the feature being tested
  
* if training new users, the fixture script can be used to setup the system into a known state so that the users
  can practice using the features of the system.

The "fixture script" service is an application-specific subclass of the abstract `FixtureScripts` service provided in
Isis' applib.  An example of this can be found in the [simple app](../intro/getting-started/simpleapp-archetype.html)
archetype, which defines `SimpleObjectsFixtureService`.  The [todo app](../intro/getting-started/todoapp-archetype.html)
archetype also does something very similar, defining a `ToDoItemsFixtureService`.

## Using Fixture Scripts in the UI ##

The normal convention is to for the (application's) fixture script service to be surfaced on a "Prototyping" menu.  Here's
how the todoapp defines its fixture script service:

    @DomainService
    @DomainServiceLayout(
        named = "Prototyping",
        menuBar = DomainServiceLayout.MenuBar.SECONDARY,
        menuOrder = "10"
    )
    public class ToDoItemsFixturesService extends FixtureScripts {
        ...
    }

On the prototyping menu the fixture script service's "run fixture script" action can be called:

<img src="images/fixture-scenarios-run.png" width="800"></img>

This brings up an action prompt that lists the available fixture scripts:

<img src="images/fixture-scenarios-choice.png" width="800"></img>

Selecting and running one of these generates a list detailing the results of running the fixture:

<img src="images/fixture-scenarios-results.png" width="800"></img>

This list acts as a useful transcript of the steps taken by the fixture script.  It also allows the user to navigate
to any of the objects created/updated by the fixture script.


## Using Fixture Scripts in Integration Tests ##

TODO


## Writing Fxture Scripts ##

Fixture scripts are implemented by subclassing the `FixtureScript` class, providing an implemention of the `execute(ExecutionContext)` method:

    package org.apache.isis.applib.fixturescripts;

    public abstract class FixtureScript ... {

        @Programmatic
        protected abstract void execute(final ExecutionContext executionContext);

        ...
    }

The `ExecutionContext` provides several capabilities to the fixture script:

* add results to the

* it allows the script to execute other child fixture scripts

## Example Usage ##

The todo app (generated by the [todo app archetype](../intro/getting-started/todoapp-archetype.html) uses fixture scripts to create a number of todo items, in different states (some complete, some not).

There are various ways of using the fixture script API, but broadly speaking it's helpful to distinguish (what we call):

* action fixture scripts - fine-grained, perform a single action (or create a single object)
* scenario fixture scripts - coarse-grained, accomplish a single business goal (or set up a bunch of related data)

Scenario scripts usually call action scripts, so we'll start by discussing action scripts first.

### Action scripts

The todo app's `ToDoItemForBuyStamps` fixture script creates a single, not yet complete todo item:

    public class ToDoItemForBuyStamps extends ToDoItemAbstract {

        public static final String DESCRIPTION = "Buy stamps";

        @Override
        protected void execute(ExecutionContext executionContext) {
            createToDoItem(
                    DESCRIPTION,
                    Category.Domestic, Subcategory.Shopping,
                    nowPlusDays(0),
                    BD("10.00"),
                    executionContext);
        }
    }

where in turn `ToDoItemAbstract` inherits from `FixtureScript`:

    public abstract class ToDoItemAbstract extends FixtureScript {

        protected ToDoItem createToDoItem(
                final String description,
                final Category category, final Subcategory subcategory,
                final LocalDate dueBy,
                final BigDecimal cost,
                final ExecutionContext executionContext) {

            // validate parameters
            final String ownedBy = executionContext.getParameter("ownedBy");
            if(ownedBy == null) {
                throw new IllegalArgumentException("'ownedBy' must be specified");
            }

            // execute
            ToDoItem newToDo = toDoItems.newToDo(
                    description, category, subcategory, ownedBy, dueBy, cost);
            return executionContext.addResult(this, newToDo);
        }

        protected LocalDate nowPlusDays(int days) {
            return clockService.now().plusDays(days);
        }

        protected BigDecimal BD(String str) {
            return new BigDecimal(str);
        }

        @javax.inject.Inject
        private ToDoItems toDoItems;

        @javax.inject.Inject
        protected ClockService clockService;
    }

In this particular design the "know-how" (to create a todo item) is encapsulated in the `ToDoItemAbstract` superclass, while the "what" (actual arguments) are in the subclass.




It's also possible for fixture scripts to call prerequisite fixture scripts.  So, this fixture script will create the "buy stamps" todo item and then complete it:

    public class ToDoItemCompleteForBuyStamps extends ToDoItemCompleteAbstract {

        @Override
        protected void execute(ExecutionContext executionContext) {

            // prereqs
            executeChild(new ToDoItemForBuyStamps(), executionContext);

            // this fixture
            complete(ToDoItemForBuyStamps.DESCRIPTION, executionContext);
        }
    }

where once more the superclass provides the "know-how":

    public abstract class ToDoItemCompleteAbstract extends FixtureScript {

        protected void complete(final String description, final ExecutionContext executionContext) {
            String ownedBy = executionContext.getParameter("ownedBy");
            final ToDoItem toDoItem = findToDoItem(description, ownedBy);
            toDoItem.setComplete(true);
            executionContext.add(this, toDoItem);
        }

        private ToDoItem findToDoItem(final String description, final String ownedBy) {
            final Collection<ToDoItem> filtered = Collections2.filter(getContainer().allInstances(ToDoItem.class), new Predicate<ToDoItem>() {
                @Override
                public boolean apply(ToDoItem input) {
                    return Objects.equal(description, input.getDescription()) &&
                           Objects.equal(ownedBy, input.getOwnedBy());
                }
            });
            return filtered.isEmpty()? null: filtered.iterator().next();
        }
    }


### Scenario scripts

Fixture scripts support the composite pattern, meaning that they can also be nested.  This allows us to create scenario scripts, to set up a bunch of data.

For example, the `ToDoItemsRecreate` fixture script sets up a whole set of todo items:

    public class ToDoItemsRecreate extends FixtureScript {

        public ToDoItemsRecreate() {
            withDiscoverability(Discoverability.DISCOVERABLE);
        }
        ...
        @Override
        protected void execute(ExecutionContext executionContext) {
            ...

            // prereqs
            executeChild(new ToDoItemsDelete(), executionContext);

            // create items
            executeChild(new ToDoItemForBuyMilk(), executionContext);
            executeChild(new ToDoItemForBuyBread(), executionContext);
            executeChild(new ToDoItemForBuyStamps(), executionContext);
            executeChild(new ToDoItemForPickUpLaundry(), executionContext);
            executeChild(new ToDoItemForMowLawn(), executionContext);
            executeChild(new ToDoItemForVacuumHouse(), executionContext);
            executeChild(new ToDoItemForSharpenKnives(), executionContext);
            executeChild(new ToDoItemForWriteToPenPal(), executionContext);
            executeChild(new ToDoItemForWriteBlogPost(), executionContext);
            executeChild(new ToDoItemForOrganizeBrownBag(), executionContext);
            executeChild(new ToDoItemForSubmitConferenceSession(), executionContext);
            executeChild(new ToDoItemForStageIsisRelease(), executionContext);
        }
    }

There's a couple of things worth pointing out here.  First, in the `execute(...)` method, note the call to the `ToDoItemsDelete` fixture script.  This is responsible for tearing down all relevant data first:

    public class ToDoItemsDelete extends FixtureScript {

        protected void execute(ExecutionContext executionContext) {
            final String ownedBy = executionContext.getParameter("ownedBy");
            isisJdoSupport.executeUpdate("delete from \"ToDoItem\" where \"ownedBy\" = '" + ownedBy + "'");
        }

        @javax.inject.Inject
        private IsisJdoSupport isisJdoSupport;
    }

Usually tear down fixture scripts will delete some logic partition of data that is under the exclusive control of the test; in the case the fact that every todo item has an owner is exploited.

Second, the scenario script is made available in the UI through the call to `withDiscoverability(...)` in its constructor:

    public class ToDoItemsRecreate extends FixtureScript {

        public ToDoItemsRecreate() {
            withDiscoverability(Discoverability.DISCOVERABLE);
        }
        ...
    }

This tells the fixture script framework that the fixture script should be listed as a choice in the UI:

<img src="images/fixture-scenarios.png" width="800"></img>

### Skip if encountered more than once



    public class ToDoItemsRecreateAndCompleteSeveral extends FixtureScript {
        ...

        private String ownedBy;
        public String getOwnedBy() { return ownedBy; }
        public void setOwnedBy(String ownedBy) { this.ownedBy = ownedBy; }

        @Override
        protected void execute(ExecutionContext executionContext) {

            // defaults
            executionContext.setParameterIfNotPresent(
                    "ownedBy",
                    Util.coalesce(getOwnedBy(), getContainer().getUser().getName()));

            // prereqs
            executeChild(new ToDoItemsRecreate(), executionContext);

            // this fixture
            executeChild(new ToDoItemCompleteForBuyStamps(), executionContext);
            executeChild(new ToDoItemCompleteForWriteBlogPost(), executionContext);
        }
    }




lookup(...)




    public class ToDoItemsRecreate extends FixtureScript {



### Parameters

When a fixture script is called


        private final static Pattern keyEqualsValuePattern = Pattern.compile("([^=]*)=(.*)");



        public String getParameter(String parameterName) {

        public String getParameters() {
            return parameters;
        }

        public String getParameter(String parameterName) {
            return parameterMap.get(parameterName);
        }

        public Map<String,String> getParameterMap() {
            return Collections.unmodifiableMap(parameterMap);
        }

        public void setParameterIfNotPresent(String parameterName, String parameterValue) {
            if(parameterName == null) {
                throw new IllegalArgumentException("parameterName required");
            }
            if(parameterValue == null) {
                // ignore
                return;
            }
            if(parameterMap.containsKey(parameterName)) {
                // ignore; the existing parameter take precedence
                return;
            }
            parameterMap.put(parameterName, parameterValue);
        }



Overriding defaults


    public class ToDoItemsRecreate extends FixtureScript {

        public ToDoItemsRecreate() {
            withDiscoverability(Discoverability.DISCOVERABLE);
        }

        private String ownedBy;
        public String getOwnedBy() { return ownedBy; }
        public void setOwnedBy(String ownedBy) { this.ownedBy = ownedBy; }

        @Override
        protected void execute(ExecutionContext executionContext) {

            // defaults
            executionContext.setParameterIfNotPresent(
                    "ownedBy",
                    Util.coalesce(getOwnedBy(), getContainer().getUser().getName()));

            ...
        }
    }

